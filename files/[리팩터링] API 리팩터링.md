리팩터링 - API 리팩터링



1. 질의함수와 변경 함수 분리하기
   1. 부수효과 없애기
   2. 겉보기 부수 효과가 전혀 없이 값을 반환해주는 함수를 추구해야 한다.
   3. Get함수(질의)안에 set(변경)이 같이 있는 경우. 
2. 함수 매개변수화 하기
   1. 두 함수의 로직이 아주 비슷하고 단지 리터럴 값만 다르다면 **중복을 없애주는 것**!
   2. 함수를 매개변수로 넣으라는 뜻이 아님 ㅋㅋ
3. 플래그 인수 제거하기
   1. 매개변수로 boolean 값 써서 제어에 사용하지 말자!
   2. 호출 할 수 있는 함수들이 무엇이고 어떻게 호출하는지를 이해하기가 어려워지기 때문이다.
4. 객체 통째로 넘기기
   1. 변화에 쉽게 대응하는 것이 목표이다.
      필요한 데이터가 달라져도 매개변수가 달라지지 않는다.
      매개변수 목록이 짧아져 이해가 쉬워진다.
      중복된 로직을 없앨 수 있다.
   2. 함수가 레코드 자체에 의존하기를 원치 않을 때에는 하지마라.
   3. 한 함수에 객체에서 가져온 값 몇개만으로 무언가를 한다면 그 객체로 옮기고
   4. 객체 전반에서 똑같은 값 몇 개만 사용하는 함수가 많다면 그 부분 클래스를 추출해야한다.
5. 매개변수를 질의 함수로 바꾸기
   1. 함수 밖에서 질의 함수로 값 받아 매개변수로 넘겨주지 말고, 함수 안에서 질의함수로 얻어오기
   2. 책임소재를 피호출함수(함수 안)으로 옮기기
   3. 매개변수를 제거하면 피 호출 함수에 원치 않는 의존성이 생길때
   4. 즉, 해당 함수가 몰랐으면 하는 프로그램 요소에 접근해야 하게 될때
6. 질의 함수를 매개변수로 바꾸기
   1. 더 이상 함수가 특성 원소에 의존하길 원치 않을 때
   2. 똑같은 input에 매번 똑같은 output, (참조 투명성)
      1. 매개변수가 아닌 getter에서 받아오면 참조 투명성 깨짐
      2. 유닛테스트할때 어려워짐
   3. 책임을 호출자로 옮기기
   4. 단점은 호출자가 복잡해진다는 단점이 있음
7. 세터 제거하기
   1. 무조건 접근자 메서드를 통해서만 필드를 다루려 할 때
      1. 심지어 생성자에서도 세터를 호출,...?
   2. 클라이언트에서 생성 스크립트를 사용해 객체를 생성할 때
      1. 생성자 이후 연속된 세터들로 객체가 완성되는 코드
      2. 애초에 만들 때만 호출될 것이라 가정된 setter라면 차라리 생성자에 넣어버리자.

8. 생성자를 팩터리 함수로 바꾸기
   1. 팩터리의 장점: 생성자보다 제약이 적다.
   2. 개인적인 장점: 2^n개의 컨스트럭터를 만들 필요가 없다.
9. 함수를 명령으로 바꾸기
   1. 명령 객체
   2. 함수를 잘게 쪼갤 수 있게 하기
   3. 일급함수를 지원하지 않는 언어라면 유일한 선택이다.
   4. 일급함수를 지원하면 대체가 가능하지만, 그래도 명령 객체가 더 좋을 때가 있다.
   5. 근데 임시변수를 어디 박아놓는가?
      클래스필드 변수로 옮긴다! 그러면 객체의 어떤 메서드에서도 호출이 가능하므로 쉽게 함수 추출이 가능하다!
   6. 함수는 프로그래밍의 기본적인 빌딩 블록 중 하나이다. 그런데 함수를 그 함수만을 위한 객체 안으로 캐븃ㄹ화하면 더 유용해지는 상황이 있다. 이런 객체를 가리켜 명령 객체 혹은 명령이라고 한다. 명령 객체 대부분은 메서드 하나로 구성되고, 이 메서드를 요청해 실행하는 것이 이 객체의 목적이다.
      명령은 평법한 함수 메커니즘보다 훨씬 유연하게 함수를 제어하고 표현할 수 있다 명령은 되돌리기와 같은 보조연산을 제공할 수 있으며, 수명주기를 더 정밀하게 제어하는 데 필요한 매개변수를 만들어주는 메서드도 제공할 수 있다. 상속과 훅을 이용해 사용자 맞춤형으로 만들 수도 있다.
      객체는 지원하지만 일급함수를 지원하지 않는 프로그래밍 언어를 사용할 때에는 명령을 이용해서 일급함수의 기능을 대부분 흉내낼 수 있다.
      비슷하게 중첩함수를 지원하지 않는 언어에서도 메서드와 필드를 이용해서 복잡한 함수를 잘게 쪼갤 수 있고, 이렇게 쪼갠 메서드들을 테스트와 디버깅에 직접 이용할 수 있다.
      이처럼 명령을 사용해 얻는 이점이 많으므로, 함수를 명령으로 리팩터링할 채비를 갖춰야할 것이다. 하지만 유연성은 복잡성을 키우고 얻는 대가임을 잊지 말아야 한다.
      그래서 일급 함수와 명령 중 선택해야 한다면, 나라면 95%는 일급함수의 손을 들어준다.
10. 명령을 함수로 바꾸기
    1. 명령의 능력은 공짜가 아니다.
    2. 로직이 크게 복잡하지 않다면 단점이 더 많으면 평범한 함수를 써주자.
11. 수정된 값 반환하기
    1. 부수효과를 없애자
       1. 데이터가 수정된다면 그 사실을 명확히 알려줘야 한다.
       2. 그런데 함수 내부에서 바꿔버리면 알기 힘들다.
       3. 리턴하게 해주고, 호출자가 그걸 받아서 set한다.
    2. 값 하나를 계산한다는 분명한 목적이 있는 함수에 효과적이다.
    3. 값 여러개를 갱신하는 데에는 비효율적이다.
    4. 함수 옮기기의 준비 작업이기도 하다.
12. 오류코드를 예외로 바꾸기
    1. 예외를 사용하면, 상단에서 모두 일일이 오류코드를 검사할 필요가 없어진다.
    2. 예외는 정확히 예상 밖의 동작일때만 쓰여야 한다.
13. 예외를 사전확인으로 바꾸기
    1. 예외도 좋지만, 예외를 던지기 전에 확인하고 처리하는게 더 좋다.