모의 질문



>  CRA에서 모든 라이브러리가 dependency에 들어가있는 이유는?



저도 궁금해서 찾아봤는데요.

[댄 아브라모브가 말하길](https://github.com/facebook/create-react-app/issues/6180),

CRA는 모든 라이브러리를 bundle된 이후에 사용하기 때문에, devdepedency와 구별이 무의미하다고 생각했고, 혹시나 있을 스크립트 오류를 방지하기 위해 dependency에 모든 라이브러리를 넣었다고 합니다.

node app 같은 경우에는 dev와 구별짓는 것이 의미가 있는데, CRA는 node app이 아니라는 것이다.



"엥? CRA에서도 `npm start` 같은 걸로 실행하는데 뭐가 node app이 아닙니까?"



웅 아니다.

CRA에서 `npm start`는 [react-script](https://velog.io/@rlaqltmxm/create-react-app-살펴보기) 라는 라이브러리를 이용하는데, 요녀석은 webpack으로 `src/index.js` 를 entry로 하는 소스파일들을 **번들링**한다.

원래 node app이었다면, dev에서만 사용할 라이브러리를 production 코드에서는 배포안하고 결정하기 위해 구별한건데,

CRA는 항상 번들링하므로 이건 node app이 아니라 항상 번들링해서 배포하는 형식이고 dev에 넣든 dependency에 넣든 항상 모든 dependency가 사용되어서 구별하는게 사실 의미가 없다는 것이다!



> npx란 무엇인가요?

npm package runner

npx를 사용하면 npm 레지스트리에서 최신의 패키지를 찾아서, 별도의 다운로드 없이 사용할 수 있다.

다운로드를 받지 않으므로, 저장공간을 소모하지 않고 로컬에서 따로 버전관리할 필요도 없다.



> 왜 Emotion을 쓰셨나요?

styled-component를 사용하는 도중에 알게된 라이브러리로, styled-component와 같은 기능을 모두 제공하고 있으며, 용량도 가볍고, [성능이 좋다](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwiJ0Kf_36zxAhWSSH0KHfCQDK8QtwIwBnoECAsQAw&url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DMN3RWhGudvw&usg=AOvVaw3OXBqnAkBRUs4UqQEofkNn)고 알려져있다. 

또한, css prop기능을 제공하고, SSR시 서버작업이 필요없다고 한다. [참고](https://velog.io/@gytlr01/emotion-정리)

이러한 다양한 장점을 가지고 있어서 styled-component 대신 emotion을 사용했다.
좀 더 성능이 뛰어나고 가벼운 툴을 원하는건 IT 종사자의 본능이니까!

하지만 styled-component를 안썼을때 생기는 이슈가 발견된다면 emotion대신 styled-component를 사용해도 무방하다고 생각한다.



> CSS-in-JS와 CSS-in-CSS의 차이점은 무엇인가요?



1. CSS-in-JS

CSS-in-JS는 자바스크립트로 CSS 요소들을 관리하는 것으로 styled-component같은 것들이 대표적인 라이브러리 입니다.

자바스크립트로 CSS를 관리하므로, 스타일 요소들을 **선언적으로 표현**할 수 있게 되고, 컴포넌트 단위로 스타일을 고려할 수 있어서 스타일의 유지보수 및 관리가 쉬워집니다.

또한, webpack의 **트리 셰이킹**을 통해서 사용하지 않는 스타일 코드들이 제거되어질 수 있어서 성능의 향상을 가져옵니다.

또한, **css자체로 테스팅**을 할 수 있게 된다는 장점이 있습니다.



하지만, 원래는 브라우저를 렌더링할때, 스타일요소와 스크립트가 병렬적으로 행해졌는데, 이제는 모든 스타일 코드가 스크립트 안에 들어가 있으므로, **스크립트가 방대**해지고 스타일이 적용되지 않은 html뼈대인 **FOUC**(flash of unstyled content)가 나타나서 좋지 않은 사용자 경험을 줄 수 있습니다.



2. CSS-in-CSS

일반적인 CSS사용법으로, CSS-in-CSS와 반대로 브라우저 렌더링 과정에서 스크립트랑 병렬적으로 다운로드 및 트리에 적용이되고, FOUC가 발생하지 않습니다.

하지만 일반적으로 사용하지 않는 스타일 시트까지 로드되어질 수 있고, 스타일 수정을 위해서는 자바스크립트 영역을 벗어나서 스타일시트 파일에서 찾아서 수정해야 한다는 단점이 있습니다.



> CSS-in-JS에서 FOUC 문제가 발생할 수 있다고 하셨는데요. 어떻게 해결할 수 있을까요?

SSR를 혼용해서 해결할 수 있다고 생각합니다.

그러니까 SPA의 단점을 SSR을 사용하여 극복하는 것입니다.
초기 페이지만, 서버에서 모든 것을 제공함으로써 FOUC를 막을 수 있을 것 같습니다.



> Context API는 무엇인가요?

컨텍스트 API는 리액트에서 내장된 함수로 전역상태 관리를 위해 사용됩니다.

원래는 상태를 관리하기 위해서, 상위 컴포넌트에서 하위 컴포넌트로 prop을 통해서 전달을 해주어야 했는데, depth가 깊어질 수록 하위 컴포넌트에 prop를 넘겨주기 위한 중간 컴포넌트들이 생기게 될 것입니다.

사용하지도 않는 prop를 받는 컴포넌트가 많아진다면, 계층 구조에 의존적인 컴포넌트가 되는 것이고 => 이는 재사용이 어렵고 유지보수가 어려운 스파게티 코드가 될 것입니다.

그래서 전역상태관리를 위해서 Context API가 나오게 되었습니다.

Consumer와 Provider로 JSX 태그를 감싸서 사용하는데, Provider로 감싼 영역에서 전역으로 상태가 관리되어지고, Consumer로 감싼 영역에서 Provider가 제공하는 상태값들을 사용할 수 있습니다.

다만, Consumer, Provider를 사용해야하므로 JSX의 가독성이 나빠지고 재사용이 어려워질 수 있습니다. 또한 Consumer가 제공하는 상태의 일부가 변경되면, 상태를 사용하지 않는 영역까지 리렌더링이 되는 이슈도 있습니다.



> Context API의 리렌더링을 해결하기 위한 방법으로는 무엇이 있습니까?

1. React.memo나 useMemo와 같은 메모이제이션 최적화를 통해서, 값이 같은 경우 리렌더링이 일어나지 않게 할 수 있습니다.
2. Context의 범위를 최소화 하여, 리렌더링의 범위를 축소하여 사용합니다.

보통 최적화는 최적화를 위한 비용 및 가독성 측면에서 좋지 않기 때문에, 사용할 경우 최대한 Context의 범위를 좁게 유지하여 리렌더링이 미치는 영향을 최소화하는 방식이 많이 사용되는 것 같습니다.



> Class Component와 Function Component의 차이는 무엇인가요?

클래스와 함수의 차이는, 클래스는 new로 인스턴스를 생성해야하면 사용할 수 있고, 함수는 인스턴스 없이 사용할 수 있다는 것입니다.

그렇기 때문에 클래스는 인스턴스와 메소드가 강제되어있습니다.

클래스는 인스턴스가 생성되기 때문에 메모리를 해제하지 않는 이상 메모리상에 존재하게 됩니다. 

상태가 바뀌어서 리렌더링이 일어나는데도, 인스턴스는 살아있는 것이죠.

만약 리액트 클래스 컴포넌트가 prop를 this로 저장하여 들고 있다면, prop이 변경될 때마다. this의 prop는 바뀐 prop을 기억하게 될 것입니다.

[아주 유명한 예제](https://codesandbox.io/s/pjqnl16lm7)

setTimeout을 통해서 3초후에 prop을 가져오게 하면, setTimeout이 호출된 시점이 아니라 3초후의 상태값을 가져오게됩니다.

"나는 분명 과거의 값을 지금 출력하도록 원했는데, 지금 가장 최신의 값이 나오는 현상"

즉, 클래스의 인스턴스가 리렌더링되어도 살아있음으로써 예기치 못한 결과가 발생할 수 있는 것인데요.

그래서 1번의 렌더링 시, 그 순간의 props와 state가 고정되어야 합니다.

class 컴포넌트의 경우에는 이를 위해서 따로 변수를 추출하거나 작업이 추가적으로 들어가게 되는데요. 코드는 결국 비용이므로 이러한 단순 저장용 변수가 많이 늘어나는 것은 별로 가독성 면이든 비용이든 결국 좋지 않다고 생각합니다.

저장용 변수를 만들지 않고 이를 구현하려면, `render` 메서드에 다른 메서드들을 넣어버리면 되는데요. 이는 function component랑 구조가 똑같습니다. [참고](https://zereight.tistory.com/956)



그래서 저는 클래스 컴포넌트를 사용함으로써 얻을 수 있는 이점은 객체지향적인것 이외에 찾기 힘든것 같습니다.

결국엔 props와 state를 불변으로 유지하기 위해서 function component 형태가 적합하고, 가독성도 좋고, 선언적이라는 장점이 있다고 생각합니다.



> 명령형 프로그래밍, 선언형 프로그래밍

명령형 프로그래밍은 무엇을 어떻게 할지에 대해서, 선언형 프로그래밍은 무엇을 할지에 대해서 프로그래밍하는 것이다.

예를 들어서 루터회관에 가는 방법을 프로그래밍으로 작성한다고 하면,

명령형 프로그래밍은 어느쪽을 몇 m이동해서 어디서 어느방향으로 틀어서 .... 등의 동작을 일일히 정의해주어야하고, 선언형 프로그래밍은 "서울특별시 송파구 잠실 루터회관으로 이동"이라고 주소만 입력하는 것이다.

나머지 어떻게 이동하는 것과 같은 건 높은 추상화로 사용자가 알필요가 없다.

즉, 선언형 프로그래밍은 가독성이 높고, 간결하고, 재사용성이 높아진다는 장점이 있습니다.

대신에, 높은 추상화로 인한, low level이 어떻게 동작하고 있는지에 대한 정보를 제공하지 않기 때문에 내부 동작의 파악이 필요한 경우에는 오히려 좋지 않을 수 있습니다.



> 공식문서에서 소개하는 React의 3가지 특징은?

선언적이다.

컴포넌트로 개발할 수 있다.

한번배워서 어디서나 사용할 수 있다.



> 리액트에서 불변성이란 무엇인가?

리액트에서 prop과 state는 불변성을 지킨다.

불변성을 지킴으로써 prop, state가 변경되었을 경우 해당 참조값만 비교하여 달라짐을 판단할 수 있기 때문에 효율적이다.

하지만 항상 불변성을 유지하는 것이 성능이 좋은 것은 아니다. 불변성을 위해서 새로운 객체를 생성하는 것도 비용이기 때문에, 게임 캐릭터의 좌표값과 같이 실시간으로 자주 변하는 값이라면 오히려 성능이 하락할 수 있다.



> Function Component인가요? Functional Component인가요?

[참고](https://gyuwon.github.io/blog/2020/07/24/react-has-no-functional-components.html)

Function 컴포넌트입니다.

Functional 컴포넌트는 함수형 컴포넌트라는 뜻인데, 함수형 프로그래밍으로 작성된 컴포넌트라는 뜻입니다.

함수형 프로그래밍라는 것은 선언형이고 순수함수이며, 부수효과가 없도록 한다.

또 다른 특징으로 **참조 투명성**을 갖는다.

참조 투명성은 해당 순수함수의 실행 결과값을, 사용하는 코드에서 치환시켰을때 동일한 결과값이 나오는지로 판단할 수 있다.

```js
const add = (a,b) => a+b;

console.log(add(3,4)) // 7
```

위 코드는 참조 투명성을 가진다.

```js
console.log(7) // 7
```

함수의 결과값을 사용하는 쪽에서 대체했을때, 같은 결과값을 기대할 수 있기 때문이다.



하지만 아래는 참조투명성을 만족하지 않는다.

```js
const add = (a,b) => {
  console.log(a+b);
  
  return a+b;
}

console.log(add(3,4)) // 7 7
```

왜냐하면

``` js
console.log(7) // 7
```



치환한 결과값을 사용했을때의 기대값이 다르기 때문이다.



리액트 컴포넌트도 그렇다.

컴포넌트에서 useEffect를 사용할 수 있다. 그리고 return 으로 JSX가 반환된다.

그럼 바깥에서 사용할때 return하는 JSX으로 대체했을때 같은 결과값을 기대할 수 있을까?

useEffect는 렌더링이 끝나고 이루어지는 작업이기 때문에, 같은 결과값을 보장할 수 없다.

**그러므로 참조 투명성을 만족하지 않고, 함수형 컴포넌트라고 부를 수 없다.**

그냥 "**함수 컴포넌트**""일 뿐이다.



> PropType에서 typescript로 바꾼 이유가 무엇인가요?

PropType과 typescript의 차이점은 런타임에서 타입을 체크하느냐 컴파일타임에서 타입을 체크하느냐 차이라고 생각합니다.

웬만하면 컴파일 타임에서 타입을 체크하는 것이 낫다고 생각했던 이유가, 어플리케이션이 거대해질수록 어플을 실행시키는게 비용이 많이들것이라고 생각했습니다. 
또한, 어플을 실행시키지 않고 타입에러는 잡아주는것이 IDE를 훨씬 똑똑하게 사용할 수 있는 방법인것 같다고 생각했습니다. 그리고 변하지 않는 값을 선언함으로써 자바스크립트 엔진의 최적화를 도와 성능 향상을 기대할 수 있습니다!



> key값을 index로 써야할 경우와 쓰지 말아야할 경우

react에서는 key값을 바탕으로 해당 레벨의 형제 요소들이 리렌더링되어야할지 판단할 수 있습니다.

그래서 key값은 유니크해야합니다.

index값도 유니크하긴 한데, 이는 배열의 순서가 바뀌어도 index는 바뀌지 않기 때문에 문제가 될 수 있습니다.

분명 배열의 순서가 바뀌었는데 key값으로는 0부터 n까지 존재하니까, 리액트가 이전과 똑같은 요소가 렌더링되어있구나라고 판단하는 것입니다.

즉, index는 해당 배열의 요소가 변하지 않는다고 확신할 수 있는 경우에만 그릴 수 있고, 그 이외의 경우에는 index가 아닌 유니크한 값이 들어가야 합니다.



> 리액트에서 재조정이란 무엇인가요?

리액트는 변경사항이 있으면 먼저 가상의 DOM에 반영을 하고 그것을 실제 DOM과 비교하여 리렌더링을 하는데 이것을 재조정이라고 한다.



> 리액트에서 ref를 사용하는 경우는 어떤 경우인가요?

전통적인 HTML 조작 방법으로 작업해야하는 것을을 보통 ref로 사용합니다.

1. focus
2. d3.js와 같은 서드파티 라이브러리 사용

이런 경우에 ref를 사용하여 해결할 수 있습니다.



> 리액트에서 state는 왜 끌어올려야 하나요?

리액트는 단방향 데이터 흐름을 가집니다. 그렇기 때문에 single source of truth를 통해서 데이터의 일관성과 신뢰성을 확보하는 것이 유리하기 때문입니다.



> 조건부 렌더링을 &&으로 할 때 주의사항이 있을까요?

`0 && somthing` 인 경우에 0이 출력되게된다는 주의사항이 있습니다.

0이 falsy이긴한테 false는 아닌 number이므로 출력이 되는 것입니다.

반면에 boolean값이었으면 `arr.length>0 && something` 이었다면 false였을 경우에 아무것도 렌더링 되지 않을 것입니다.

이는 리액트가 JSX를 파싱하면서 false, true이런 boolean값들은 모두 제거를 해버립니다. undefined가 출력되지 않는 이유도 마찬가지 입니다.



> 리액트는 어떻게 태어나게 되었나요?

https://overreacted.io/ko/react-as-a-ui-runtime/

http://wiki.sys4u.co.kr/pages/viewpage.action?pageId=8553032



리액트를 만든 페이스북은 원래 PHP를 사용했었다. 2010년 XHP라는 성능이 높아진 PHP를 발표하게 되었는데 (XML, HTML 다루는것이 개선된거였음)

이것을 브라우저로 옮기고자 했고, 이것이 React 라이브러리가 되었다.
이때 JSX라는 js확장 문법을 만들어 XHP와 유사한 기능을 하도록 했다.

React가 나오기 전까지는, 앵귤러/백본/녹아웃/엠버 등 수많은 프론트엔드 프레임워크가 존재했다.

이들은 MVC, MVP, MVVM, MVW 등의 패턴들로 이루어져 있는데, 이들은 M(model)이라는 개념이 포함되어 있었다.

그 때문에 어떤 DOM에서 뭘 가져와서 어떤 방식으로 어떤 View를 업데이트 해줄지에 대한 로직을 모두 정해주어야 했다. 
그래서 어플리케이션이 커질 수록 복잡도가 높아지게 된다는 문제점이 항상 존재했다.

그래서 페이스북은 다른 방식으로 아키텍처를 설계한다.

"데이터를 바꿀일이 있으면 view를 날리고 새로그리자"

그러면 복잡한 작업없이 간단하게 그릴 수 있게 되고, 기존의 M** 방식들 보다 복잡도가 덜하게 소프트웨어를 개선할 수 있다.



> 리액트를 사용하면서 느낀 장,단점이 있나요?

장점

1. 사용하기에 어려움이 크지 않았다.
2. 단방향 데이터 바인딩이라, 디버깅이 쉬웠다.
3. 레퍼런스가 많다.
4. 호환성이 높은 라이브러리가 많다.
5. 재사용성이 높은 컴포넌트가 가능하다.
6. JSX너무 편하다.



단점

1. 리액트는 상호작용이 가능한 인터페이스를 쉽게 만들어주는 View 라이브러리인데, 그 이상으로 많은 것을 해주어서 정체성에 혼란을 느끼는 경우가 있는 것 같다.



> Virtual DOM은 왜 성능 향상을 가져오나요?

view에 변화가 있을것이라면, 실제 DOM에 적용되기 전에 가상의 DOM에 먼저 적용시키고, 최종적인 결과를 실제 DOM으로 전달해주는 것이다.

그리고 Virtual DOM은 실제로 그려지는 것이 아니라, 메모리상에 존재하는 것이기 때문에 속도가 빠르다.

즉, view의 변경사항이 한번만 반영되기 때문에 브라우저 렌더링 연산이 한번만 일어나게 되고 이것이 성능향상을 가져온다.



> Virtual DOM은 항상 DOM보다 빠른가요?

충분히 빠르지만 항상 빠른 것은 아니다.

최적화가 덜되어있거나, 정보제공 목적의 페이지처럼 유저와의 상호작용이 적은 페이지라면 오히려 DOM으로 조작하는것이 더 빠를 수 있다.



> 리액트에서 side effect란 무엇인가요?

비동기 처럼 컴포넌트 렌더링이 끝나고, 컴포넌트 외부에서 상태에 변화를 주는 것을 사이드 이펙트라고 한다.



> 원시타입에는 어떤 것들이 있나요?

number, boolean, string, null, undefined, bigint, symbol



> 비즈니스 로직이란 무엇인가요?

유저의 눈에는 보이지 않지만, 유저가 바라는 결과물을 올바르게 도출할 수 있도록 짜여진 코드 로직을 말한다.



> interface와 type alias 차이는 무엇인가요?

interface 는 타입스크립트에서 일반적으로 사용되는 타입 체크 형태로써, 객체 문법과 유사해서 객체타입에 적용하기 알맞습니다. 또한 같은 네임의 인터페이스가 있는 경우 그것을 확장하여 사용할 수 있다.

type alias는 타입을 정의하는 것으로써 주로 union이나 tuple형에서 사용되어진다. 또한 type alias는 확장되지 않고, 같은 네임이 존재하는 경우 에러를 throw한다. 

자바스크립트는 객체기반의 언어이기 때문에 다수의 상황에서 interface를 사용하여 타입을 정의해주는 경우가 일반적이다.



> 타입 추론과 타입 단언의 차이?

타입 추론: 타입스크립트가 코드를 분석해서 타입을 확인하는것

타입 단언: 프로그래머가 타입스크립트에게 as를 사용하여 타입을 단언해주는 것.



> any, unknown, never의 차이

any는 타입검사를 항상 만족하고 대입도 할 수 있는 타입으로, 일반 자바스크립트의 선언과 똑같아집니다.
객체에 존재하지도 않는 프로퍼티에 접근해도 컴파일러가 검사하지 않아서 문제없다고 판단합니다.

unkown은 존재할 수 있는 모든 타입들을 포함하여 어떤 값이든 가질 수 있다(슈퍼셋)는 점에서는 any와 유사하지만, unkown은 어떤 값이든 될 수 있으므로 모든 타입이 공통적으로 할 수 있는 연산외에는 할 수 없도록 강제합니다.

never는 모든 타입의 서브셋으로, never타입은 어떤 다른 값도 할당할 수 없게된다. never는 함수가 어떠한 값도 반환하지 않거나, 특정 타입값을 할당못하도록 조건문으로도 [사용](https://xo.dev/typescript-unknown-any-never/)할 수 있습니다.



> Hook에서 꼭 지켜야할 규칙은?

컴포넌트의 최상단에 정의되어야 한다.

왜냐하면 react는 어떤 컴포넌트에서의 훅의 호출순서를 기억하여 그 훅이 담당하는 상태값과 매핑할 수 있기 때문에, 조건문/반복문 아래에 선언되면 호출 순서가 꼬일 위험이 있기 때문이다.



> 제어 컴포넌트와 비제어 컴포넌트의 차이점은 무엇인가요?

제어 컴포넌트는 컴포넌트의 value를 react의 상태값과 항상 일치키시는 컴포넌트로, 실시간으로 포매팅, 유효성검사가 가능하다.
React를 통해서 값이 관리되므로 source of truth를 만족하고 값이 예측가능해진다.

비제어 컴포넌트는 전통적인 HTML을 조작하는 방식과 유사한 컴포넌트로, 필요할때 DOM을 사용자가 접근할 수 있게 해준다.



> 제어 컴포넌트를 지향해야 하는 이유는 무엇인가요?

제어 컴포넌트를 지향해야 하는 이유는 상태관리 및 DOM작업의 제어를 리액트에게 위임함으로써 예측가능한 상태관리가 되도록 하기 위함입니다.

비제어 컴포넌트는 ref를 사용하여 리액트의 life cycle을 따르지 않기 때문에 리액트 동작과정이 어디선가 꼬일 위험이 있고, ref 코드 자체가 지저분하고 관리가 쉽지 않기 때문에 되도록이면 제어컴포넌트를 지향하라는 것입니다.



> 무조건 제어 컴포넌트가 좋은가요?

제어 컴포넌트는 항상 view와 리액트의 상태값을 동기화하기 때문에 상태가 변할때마다 리렌더링 될 수 있습니다. 이것또한 비용의 일부이기에 상황에 맞게 적절하게 사용하면 될 것 같습니다. 아무튼 항상 무조건 좋은것은 아닙니다.



> dependencies array는 항상 채워져야 할까요?

대부분의 경우에 채워져야하는 것이 맞습니다.

리액트는 의존성 배열에 들어있는 값이 변했는지를 비교하고 변했을 시 특정 작업을 수행하는데, 
일부러 의존성 배열을 비운다는 것은 컴포넌트가 리액트에게 거짓말을 친다는 것입니다.

리액트가 모든 컴포넌트와 상태들을 관리해야하는데, 거짓말을 치는 컴포넌트가 많아질 수록 분명히 버그의 위험도는 증가할 것이므로 좋은 습관이라고 할 수 없습니다.

다만, redux의 dispatch처럼 절대로 변할일이 없는 함수들은 꼭 넣지 않아도 됩니다.



> useEffect를 남용해서는 안되는 이유는 무엇인가요?

useEffect는 부수효과를 사용하겠다는 것입니다. 컴포넌트가 렌더링된 이후에 어떤 작업을 할 것이라고 리액트에게 알려주는 것입니다.

당연히 렌더링 이후에 작업을 수행하는 일이 많아지면, 필연적으로 상태의 예측이 어려워지고, 코드의 가독성도 좋지 않습니다.



> fetch와 axios의 장단점은?

axios는 별도의 설치가 필요하지만 fetch와 달리 body에서 stringify를 해줄 필요가 없고 요청을 취소할 수 있는 등의 fetch에서 제공하지 않는 다양한 메서드들을 제공되어서 상당히 편했습니다. 

또한 fetch는 폴리필이 필요한 반면에, axios는구형브라우저를 지원합니다. 
CSRF 보호 기능이 내장되어있기도 하다고 하고, node.js에서 사용이 가능합니다. fetch는 window객체임!



> Lazy initial state에 대해서 아니사요?

`useState` 같은 경우도 결국엔 함수 컴포넌트 내에서 사용되어지기 때문에 렌더링될때마다 호출되어진다.

즉, `useState`의 초기값 연산이 렌더링 마다 매번 이루어진다는 뜻이다.

이것을 해결하기위해 나온것이 "Lazy Initial State"이다. 

`useState` 초기값을 반환하는 함수를 인자로 넘김으로써 React Component가 생성될 때만 state가 생성되게 해주는 것이다.



> a vs Link 태그?

a태그는 아예 다른 페이지로 이동함으로써 현재 상태가 모두 증발하게 되지만, Link는 pushState처럼 현재 상태값이 유지된 상태로 라우팅을 할 수 있다.



> createRef vs useRef 차이점은?

createRef와 useRef모두 ref를 생성하기 위함인데, 함수 컴포넌트에서 createRef를 사용하게 되면 렌더링 시 마다 생성되게 된다.

그래서 useRef를 사용하여 상태로 만듦으로써 렌더링시마다 생성이 반복되는 것을 막을 수 있다.



> 값, 식, 문에 대해서 설명해주세요.

식은 값이고 문은 값이 아닌 것이다.

모든 식은 값으로 평가가 되고, 문은 어떤 코드 플로우의 집합인 것이다.

어셈블리 단에서 비교하자면 값/식과 달리 문은 loop나 jmp, 브랜치 같은 점핑 명령어가 존재하는 것으로 구별할 수도 있다.



> 동적 타이핑과 정적 타이핑은 무엇인가요?

동적 타이핑은 자바스크립트 같이 타입이 런타임에서 결정되는 것을 말하고,

정적 타이핑은 타입스크립트처럼 컴파일 시에 변수의 타입이 결정되는 것을 말합니다.



동적 타이핑은 런타임에 타입이 결정되므로 유연성이 높고 코드 작성이 빠를 수 있지만, 런타임 시에 갖가지 에러가 날 수 있고, 코드가 복잡할 시, 에러가 발생시 디버깅이 어렵다는 특징이 있습니다.

정적 타이핑은 컴파일에 타입이 결정되므로 개발자가 타입을 명시해주어야해서 코드의 작성이 느릴 수 있으나, 타입을 정해놓았으므로 자바스크립트 엔진이 최적화를 잘할 수 있고 프로그램의 실행속도가 높아지고, 코드의 안정성도 보장해줍니다.



> 런타임과 컴파일 타임의 차이점에 대해서 알려주세요

런타임은 컴파일 이후에 프로그램이 실행되어지는 시기이고,

컴파일타임은 소스코드가 컴퓨터가 이해할 수 있는 기계어로 변환되는 시기를 뜻한다.



> 라이브러리와 프레임워크의 차이는 무엇인가요?

라이브러리는 특정 기능들을 사용하기 쉽게 모든 코드의 집합입니다. 그래서 코드가 라이브러리를 호출하여 사용합니다.

그리고 코드는 프레임워크가 호출하여 사용합니다.

즉, 코드의 플로우 제어 권한을 누가 가지고 있냐의 차이로 구별할 수 있습니다.

어플리케이션이 들고 있게 제어를 넘기는 주체가 바로 프레임워크이고, 
사용자가 코드의 흐름을 제어하여 사용하는 것이 라이브러리 입니다.



> 덕스 패턴이란 무엇인가요?

덕스 패턴은 구조중심이 아니라 기능중심으로 파일을 나누는데, 그로 인해서 

redux에서 하나의 기능을 수정하려고 하면, 이 기능과 관련된 여러개의 파일을 수정해야하는 일이 생겨서 덕스패턴이 나왔습니다.

즉, 1개의 기능에 해당하는 action type, action creator, reducer등을 하나의 파일에서 관리하는 패턴입니다.



> 덕 타이핑이란 무엇인가요?

덕 타이핑은 동적 타이핑의 한 종류로, 
객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것을 말합니다.

"오리처럼 걷고 소리내면 오리라고 결정한다 (실제로 오리가 아니더라도)"



> 일급 객체란 무엇인가요?

일반적으로 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체를 가리킨다.

1. 변수에 할당가능
2. 인자로 전달가능
3. 반환값으로 사용가능

이것으로 자바스크립트는 고차함수 및 콜백 패턴을 사용가능하다.



> 브라우저 렌더링 과정은?

브라우저 렌더링은 다음과 같은 순서로 일어납니다.

1. DOM Tree가 생성
2. Render Tree가 생성
3. reflow
4. repaint



> 리덕스에서 context api를 사용하고 있는 것으로 아는데, 왜 리덕스를 사용하셨나요?
>
> Context api의 re-render 되는 문제를 그대로 안고 가는것 아닌가요?

https://stackoverflow.com/questions/66972103/why-context-api-is-worse-than-redux-for-high-frequency-updates

자체적으로 처리하고 있다!



> enum, const enum, union types 에 대해서 설명해주세요

enum은 열거형으로 사용되는 타입스크립트에서 제공되는 문법이다. 역맵핑이 필요한 객체를 생성할 때에도 쓰인다.

enum은 치명적인 단점이 있는데, 트랜스 파일링하면 IIFE로 변해서, 트리셰이킹 대상이 되지 않는 것이다.

이를 해결하기 위해서 const enum을 사용할 수 있는데, const enum을 사용하면 IIFE가 아니게된 상태로 트리셰이킹이 되나, 역맵핑이 일어나지 않고, 한자나 일본어가 트랜스파일링되지 않는다는 오류가 있다.

마지막으로 union types는 트랜스파일링도 잘되고 트리셰이킹도 잘되어서 굳이 열거형 enum이 필요한 경우가 아니면 union types으로 선언하면 좋을 것 같다.



> Presentation, Container 컴포넌트를 나눈 이유가 무엇인가요?

react는 원래 사용자와 상호작용이 가능한 UI를 효과적으로 개발하기 위해 탄생한 라이브러리로, view와 관련이 깊은 라이브러리입니다.

그래서 react는 최대한 view만 담당하게 하고 싶었고, 어쩔 수 없이 데이터를 처리해야하는 부분이 있는데 그것을 container 컴포넌트에서 담당하도록 관심사를 분리해서 관리를 하고 싶었습니다.

실제로 분리를 하니까, 스타일나 UI적인 요소는 presentation 컴포넌트에서, 데이터 관련 로직은 container 컴포넌트에서 수정을 하면되어서 유지보수나 가독성도 개인적으로 높다고 느꼈습니다.





> 브라우저 주소창에 주소를 입력후 엔터를 누르면 생기는 동작 전체를 설명해주세요.

1. 브라우저의 주소창에 URI를 입력하면
2. 브라우저는 DNS 도메인 네임 시스템을 운영하는 서버를 통해서 IP주소를 받아온다. (DNS는 도메인이름과 IP를 맵핑하고 있는 정보를 들고 있다.)
3. 브라우저는 받아온 IP로 요청을 보낸다.
4. 해당 서버가 요청을 받고 렌더링 재료 (HTML,CSS,JS)를 보내준다.
5. 브라우저는 그것을 그린다.



> html을 파싱할때 script를 만나면 멈추고, StyleSheet를 만나면 안멈추나요?

https://hsp0418.tistory.com/144



브라우저는 script 태그를 만나는 순간 즉시 해석하고 실행한다.

그리고 HTML 파싱은 중단된다.

왜냐하면 DOM 트리를 변경이 있을 수 있기 때문이다.



반면에, 스타일 시트는 DOM 트리를 변경하지 않기 때문에 문서파싱을 중단하지 않는다.



> innerText vs textContent

innerText는 최종적으로 화면에 렌더링 된 모습을 가져온다.

개행이 많이 되어있어도 렌더링 시에는 공백이 1개로 보이므로 innerText로 가져오면 공백이 1개로 보인다. 
즉, 줄바꿈처럼 의도적으로 스타일링이 들어간 후의 모습이 된다.

반면에 textContent는 raw text를 가져오고 줄바꿈이 여러개있다면 여러개 있는 상태 그대로 출력된다.

그리고 raw text만을 가져와서 속도면에서도 innerText보다 유리하다고 할 수 있다.



> Promise의 3가지 상태

reject: 비동기 처리 로직이 실패

pending: 비동기 처리 로직이 아직 완료되지 않음

fulfilled: 비동기 처리 로직이 완료됨



> script, script async, script defer 차이

브라우저는 html를 읽다가 script 태그를 만나면 멈춘다.

defer는 script를 백그라운드에서 다운로드한다. 그래서 다운로드 도중에는 html파싱이 멈추지 않는다.
그리고 html파싱이 끝날때까지 지연되다가 파싱이 끝나면 그 때 script가 실행된다.

async는 페이지와 완전히 독립적으로 script를 처한다. defer처럼 백그라운드에서 다운로드되며, 다운로드가 되면 스크립트를 바로 실행한다. (스크립트를 실행하는 도중에는 html 파싱 멈춤) 
또한 먼저 다운로드된 script가 먼저 실행된다. 
(방문자 수나, 광고관련 스크립트에서 주로 사용됨)



> 콜백지옥을 해결하는 방법

콜백 지옥이 생기는 이유는 비동기 절차를 동기적으로 해결하려다 보니 생긴 현상이다.

1. 기명함수로 전환
   콜백함수들에 이름을 달아서 외부로 추출한다음 사용하는 방법

   가독성을 높일 수 있어서 콜백지옥같은 느낌이 들지 않는다.

2. Promise로 전환
   new Promise를 사용하여 콜백을 제거하는 방법이다.
   대신에 Promise Hell에 빠질 수 있다.

3. Generator로 전환

   제너레이터를 사용해서 비동기 작업이 완료되는 시점마다, next를 사용하면 동기적으로 위에서부터 아래로 진행되게 할 수 있다.

4. Promise + async/await로 전환

   async/await를 사용함으로써 비동기 절차를 동기적으로 동작하게 할 수 있다.



> typescript에서의 void는?

타입스크립트에서 void는 "이 함수는 아무것도 반환하지 않는다"라는 의미를 부여한다.



> 유사배열 객체는?

유사배열 객체는 객체이지만 Array처럼 사용할 수 있게 만든 것이다.

자바스크립트가 객체기반언어인 점을 이용한 트릭이다.

실제로 0,1,2,3에 해당하는 프로퍼티를 가지고 있고 length도 가진다.

```js
const fake = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
}

fake[1]; // 'b'
fake.length; // 3;
```

대신에 Array의 메서드를 사용할 수 없다.

사용하려면 Array.from으로 바꿔주거나 call/apply를 사용해야한다.



> 자바스크립트에서 모듈이란?

특정한 목적을 지닌 함수들로 구성된 라이브러리이다.



> Promise.all, Promise.race 차이는?

Promise.all은 들어온 모든 비동기함수를 병렬적으로 처리하며 resolve된 결과값을 차례대로 배열로 반환한다.

Promise.race는 가장 먼저 값이 반환된 비동기함수의 결과값을 리턴한다.



> bind와 apply/call의 차이는?

bind는 새로운 함수 레퍼런스가 반환되고, apply/call은 사용즉시 새로정의된 함수가 실행된다.



> bind, apply, call에 첫번째 인자값을 null을 주면, 해당 함수의 this는 어떻게 되나요?

기본 바인딩으로 전역 객체가 바인딩됩니다.



> 클로저란 무엇인가요?

함수가 선언될 때 외부의 lexical 환경을 참조할 수 있는 원리를 이용한 함수로,

접근하려고 하는 상위 스코프의 생명주기가 종료되었지만, 함수 내부에서 상위 스코프의 지역변수에 접근할 수 있는 함수를 말합니다.



> 클로저의 목적은 무엇인가요?

전역변수를 사용하지 않고, 일정한 스코프를 갖는 변수를 다룰 수 있다.



> 클로저에서 메모리 관리는 어떻게 할 수 있나요?

식별자가 있다면 null이나 undefined를 할당하여 참조 카운트가 0이되에해서 GC가 수거해가도록 한다.



> 커링이란 무엇인가요?

커링은 클로저를 사용하여 사용하고자 하는 인자를 하나씩 차례대로 받게 구현한 트릭이다.

가독성이 좋아지고, 각 함수의 재사용성이 높아진다.

하지만 depth가 깊어지면 스코프가 꼬일 수 있다.



> 클로저와 커링은 무슨 관계인가요?

커링이 클로저를 사용하는 관계



> SPA란 무엇인가요?

단일 웹페이지 어플리케이션



> SPA의 장단점은 무엇인가요?

1개의 번들파일을 받으므로 초기 구동 속도가 느리다. (코드 스플리팅 필요)

SEO가 어렵다. (구글 검색엔진을 제외한 다른 엔진들은 SPA의 root페이지만 크롤링할 수 있음)

빠른 인터렉션으로 사용자에게 좋은 경험을 준다.





> AJAX란 무엇인가요?



> PJAX란 무엇인가요?



> aria-label 이란?



> RESTful API란



> CORS



> 실행 컨텍스트란 무엇인가요



> Prototype은 무엇인가요?

https://mygumi.tistory.com/312?category=642142

프로토 타입은 원형이라는 뜻으로, 자바스크립트에서는 자신을 통해 만들어질 객체의 원형을 뜻한다.

Prototype Link: 자신을 만들어낼 객체의 원형

Prototype Object: 자신을 통해 만들어질 객체의 원형

![prototype](https://t1.daumcdn.net/cfile/tistory/99E4F84C5ADC20D817)

![img](https://blog.kakaocdn.net/dn/bjco0Q/btq1nIYtuY9/ZECp6COpXZJMNk3fegHZz0/img.png)



> 렉시컬 스코프란 무엇인가요?



> 스코프 체인은 무엇인가요?



> 이미지를 미리 로딩하는 방법에는 무엇이 있나요?



> 디바운스와 쓰로틀링의 차이를 아시나요?



> 웹팩이란 무엇인가요?



> Promise란 무엇인가요?

Promise는 자바스크립트 비동기 처리에 사용되는 객체이다.



> Promise와 Callback의 차이



> Promise와 async/await의 차이



> Promise와 generator의 차이

Promise는 비동기 동작이 끝났을때의 결과값을 반환되게 함으로써 비동기를 구현할 수 있고

generator는 yield 명령어를 사용하여 원하는 시점에 다음 동작을 수행하게 함으로써 비동기를 구현할 수 있다.



> for...in, for...of 의 차이는?

**for**...in은 객체에서 사용하고, **for**...of**는** 배열에서 사용한다



> 웹팩이 모든 자원을 모듈로 가지면서 얻을 수 있는 이점은?



> 웹팩의 4가지 구성요소는?



> 웹팩에서 entry와 plugin의 차이점은?



> 스코프와 컨텍스트의차이는?

스코프는 변수의 범위와 관련이 있고, 컨텍스트는 함수가 실행되는 객체를 뜻한다.

스코프: 함수 내에서 변수에 대한 접근이 어떻게 되는지를 나타냄

컨텍스트: this 키워드 값이 무엇인지를 나타내는 용어



> 함수 스코프와 블록 스코프의 차이는?



> 자바스크립트의 GC 동작 원리



> setInterval과 setTimeout를 재귀로 구현한 것의 차이를 아시나요?



> 바인딩의 종류와 우선순위에 대해서 알려주세요



> http란?



> http status code



> 리액트에서 라우팅이란 뭔가요?

알맞은 주소에 따라서 알맞은 view를 보여주는 것



> TDZ란?



> 호이스팅은 변수선언이 먼저되나요? 함수선언이 먼저되나요?

함수가 먼저되는 것과 같은 원리이다.
https://www.inflearn.com/questions/11870



> DOMContentLoaded와 load 이벤트의 차이

DOMContentLoaded: HTML가 모두 로드되고 DOM트리가 완성된 시점. 아직 img등이 로드되지 않음

load: 브라우저에 모든 리소스가 로드되었을 때

