# 리팩터링 - 기능 이동 



## 함수 옮기기



- 배경

좋은 소프트웨어 설계의 핵심은 모듈화가 얼마나 잘 되어 있느냐를 뜻하는 모듈성이다.

모듈성이란 프로그램의 어딘가를 수정하려 할 때 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력이다.

모듈성을 높이려면 서로 연관된 요소들을 함께 묶고, 요소 사이의 연결관계를 쉽게 찾고 이해할 수 있도록 해야한다.

하지만 프로그램을 얼마나 잘 이해했느냐에 따라 구체적인 방법이 달라질 수 있다.

보통은 이해도가 높아질수록 소프트웨어 요소들을 더 잘 묶는 새로운 방법을 깨우치게 된다.

그래서 높아진 이해를 반영하려면 요소들을 이리저리 옮겨야 할 수 있다.



모든 함수는 어떤 컨텍스트 안에 존재하낟. 전역 함수도 있지만 대부분은 특정 모듈에 속한다.

객체 지향 프로그래밍의 핵심 모듈화 컨텍스트는 클래스이다.

또한 함수를 다른 함수에 중첩시켜도 또 다른 공통 컨텍스트를 만들게 된다.



프로그래밍 언어들은 저마다의 모듈화 수단을 제공하며, 각각의 수단이 함수와 살아 숨 쉬는 컨텍스트를 만들어준다.

어떤 함수가 자신이 속한 모듈 A의 요소들보다 다른 모듈 B의 요소들을 더 많이 참조한다면, 모듈 B로 옮겨줘야 마땅하다. 이렇게 하면 캡슐화가 좋아져서, 이 소프트웨어의 나머지 부분은 모듈 B의 세부사항에 덜 의존하게 된다.

이와 비슷하게, 호출자들의 현재 위치나 다음 업데이트 때 바뀌리라 예상되는 위치에 따라서도 함수를 옮겨야할 수 있다.

예컨데 다른 함수 안에서 도우미 역할로 정의된 함수 중, 독립적으로 고유한 가치가 있는 것은 접근하기 더 쉬운 장소로 옮기는 것이 더 낫다.

또한 다른 클래스로 옮겨두면 사용하기 더 편한 메서드도 있다.



함수를 옮길지 말지를 정하기란 쉽지 않다. 그럴 땐 대상 함수의 현재 컨텍스트와 후보 컨텍스트를 둘러보면 도움이 된다. 

대상함수를 호출하는 함수들은 무엇인지, 대상 함수가 호출하는 함수들은 또 무엇이 있는지, 대상 함숙 ㅏ사용하는 데이터는 무엇인지를 살펴보아야한다.

서로 관련된 여러 함수를 묶을 새로운 컨텍스트가 필요해질 때도 많은데, 이럴 때는 여러 함수를 클래스로 묶기나 클래스 추출하기로 해결할 수 있다.

함수의 최적 장소를 정하기가 어려울 수 있으나, 선택이 어려울수록 큰 문제가 아닌 경우가 많다.

경험상 함수들을 한 컨테긋트에 두고 작업해보는 것도 괜찮다.

그곳이 얼마나 적합한지는 차차 깨달아갈 것임을 알고있고, 잘 맞지 않다고 판단되는 위치는 언제든 옮길 수 있으니 말이다.



## 필드 옮기기

- 배경

프로그램의 상당 부분이 동작을 구현하는 코드로 이루어지지만 프로그램의 진짜 힘은 데이터 구조에서 나온다. 주어진 문제에 적합한 데이터 구조를 활용하면 동작 코드는 자연스럽게 단순하고 직관적으로 짜여진다. 반면 데이터 구조를 잘못 선택하면 아귀가 맞지 않는 데이터를 다루기 위한 코드로 범벅이 된다.

이해하기 어려운 코드가 만들어지는데서 끝나지 않고, 데이터 구조 자체도 그 프로그램이 어떤 일을 하는지 파악하기 어렵게 한다.

그래서 데이터 구조가 중요하다. 하지만 훌륭한 프로그램이 갖춰야 할 다른 요인과 마찬가지로 제대로하기가 어렵다.

가장 적합한 데이터 구조를 알아내고자 프로젝트 초기에 분석을 해본결과, 경험과 도메인 주도 설계같은 기술이 내 능력을 개선해줌을 알아냈다.

하지만 나의 모든 기술과 경험에도 불구하고 초기 설게에서는 실수가 빈번했다.

프로젝트를 진행할수록 우리는 문제 도메인과 데이터 구조에 대해 더 많은 것을 배우게 된다.

그래서 오늘까지는 합리적이고 올바랐던 설계가 다음 주가 되면 잘못된 것으로 판명나곤 했다.



현재 데이터 구조가 적절치 않음을 깨닫게 된다면, 곧바로 수정해야 한다. 고치지 않고 데이터 구조에 남겨진 흠들은 우리 머릿속을 혼란스럽게 하고 훗날 작성하게 될 코드를 더욱 복잡하게 만들어버린다.

예컨데 함수에 어떤 레코드를 넘길때마다 또 다른 레코드의 필드도 함께 넘기고 있다면, 데이터 위치를 옮겨야 할 것이다. 함수에 항상 함께 건네지는 데이터 조각들은 상호 관계가 명확하게 드러나도록 한 레코드에 담는게 좋다. 변경 역시 주요한 요인이다.

한 레코드를 변경하려 할때, 다른 레코드의 필드까지 변경해야만 한다면 필드의 위치가 잘못되었다는 신호다.

구조체 여러 개에 정의된 똑같은 필드들을 갱싱해야 한다면 한 번만 갱신해도 되는 다른 위치로 옮기라는 신호이다.



필드 옮기기 리팩터링은 대체로 더 큰 변경의 일환으로 수행된다. 예컨대 필드 하나를 잘 옮기면, 그 필드를 사요하던 많은 코드가 원래 위치보다 옮겨진 위치에서 사용하는게 더 수월할 수 있다.

그렇다면 리팩터링을 마저 진행하여 호출 코드들까지 모두 변경한다.

비슷하게, 옮기려는 데이터가 쓰이는 패턴때문에 당장은 필드를 옮길 수 없을 떄도 있다.

이럴땐 사용 패턴을 먼저 리팩터링한 다음에 필드를 옮겨준다.



지금까지의 설명에서 레코드라는 용어를 썼지만, 레코드 대신 클래스나 객체가 와도 똑같다. 클래스는 함수가 곁들여진 레코드라고 할 수 있으며, 다른 데이터와 마찬가지로 건강하게 관리되어야 한다.

클래스의 데이터들은 접근자 메서드들 뒤에 감추어져 있으므로 클래스에 곁들여진 함수들은 데이터를 이리저리 옮기는 작업을 쉽게 해준다.

데이터의 위치를 옮기더라도 접근자만 그에 맞게 수정하면 클라이언트 코드들은 아무 수정없이도 동작할 것이다. 따라서 클래스를 사용하면 이 리팩터링을 수행하기가 더 쉬워지며, 그래서 이어지는 설명에서는 클래스를 사용한다고 가정한다. 캡슐화되지 않는 날것의 레코드를 사용해도 똑같이 변경할 수는 있지만, 더 까다로울 것이다.



