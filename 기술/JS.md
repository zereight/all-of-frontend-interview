[함수에 대해 아는 대로 말해보세요.](#what-is-function)

[일급 객체란 무엇인가요?](#first-class-object)

[함수 표현식, 함수 선언식이란 무엇인가요?](#function-expresstion)

[값, 식, 문](#literal-expression-statement)

[화살표 함수와 function의 차이점은 무엇인가요?](#arrow-function-vs-regular-function)

[함수형 프로그래밍이란 무엇인가요?](#functional-programming)

[즉시 실행 함수 (IIFE)](#iife)

[옵셔널 체이닝은 언제 사용해야 하나요?](#optional-chaining)

[컨텍스트와 스코프에 대해서 설명해주세요.](#context-scope)

### What is function

> 함수의 정의

함수라는 용어 자체를 생각하자면, 어떤 함(函)에 input을 넣어서 그에 상응하는 output이 나오는 개념을 일컫는 말입니다. 실제 사용자는 "함"에 들어있는 동작을 몰라도 input을 넣어서 output을 얻을 수 있습니다.

> js에서의 함수 특징

자바스크립트에서는 함수는 function으로 표현할 수 있습니다,
function은 그 자체로 하나의 type으로 취급됩니다. 함수를 변수에 대입할 수도 있고, 함수에 프로퍼티를 지정하는 것도 가능합니다. 그리고 함수안에 함수도 정의할 수 있습니다.
이러한 자바스크립트에서의 함수를 [일급 객체](#first-class-object) 라고도 부릅니다.

> js에서 함수 사용법

자바스크립트 함수는 function예약어 => function 이름 => 괄호열기 => 파라미터들을 `,`로 구분하여 나열 => 괄호닫기 => 중괄호로 싸여진 코드블록
형태로 사용할 수 있습니다.

지금 설명드린 것과 다르게, function에 이름을 생략하여 익명함수를 사용할 수도 있습니다.

그리고 함수의 output은 `return`이라는 예약어를 통해 사용할 수 있습니다.
만약 자바스크립트에서 함수에 return을 안해줬다면 `undefined`가 반환되게 됩니다.

또한, 함수를 어떻게 정의하느냐에 따라서 [함수 표현식과 함수 선언식](#function-expresstion)으로 나뉩니다.

> 함수 실행의 6단계

기본적으로 함수의 동작을 caller와 callee로 표현하는데요.

함수 실행의 6단계는 다음과 같습니다.

0: 일단 현재 PC(프로그램 카운터)를 LR(링크 레지스터)에 저장한다.

1. caller는 callee가 액세스할 수 있는 a0~a3 총 4개의 레지스터에 파라미터 저장을 한다. (파라미터 개수가 4개를 넘어가면 스택에 저장)
2. caller가 callee에게 "너가 해!" 제어권을 넘긴다.
3. callee가 메모리 공간을 할당받는다.
4. callee는 이제 자기 할 일을 한다.
5. callee는 caller가 액세스할 수 있는 v0~1 레지스터에 리턴값을 저장한다.
6. callee는 v레지스터에 저장된 값을 넘기고, 제어권이 caller에게 넘어간다.

7: LR(링크 레지스터)에 있던 주소값을 PC로 전달하여 원래 동작을 수행한다.

[https://peter-cho.gitbook.io/book/7/7_2](https://peter-cho.gitbook.io/book/7/7_2)

</a>

### First class object

> 일급 객체의 정의

일급 객체란 아래 3가지 조건을 충족하면 1급 객체라고 부를 수 있다.

1. 변수나 데이터에 할당 할 수 있어야 한다.
2. 인자로 넘길 수 있어야 한다.
3. 리턴값으로 리턴할 수 있어야 한다.

즉, 특정언어에서 일급 객체란, 일반적으로 다른 객체들에 적용가능한 연산을 모두 지원하는 객체를 가리킨다.

아래는 일급 함수의 특징이다.

4. 익명으로 생성이 가능하다.
5. 런타임에 생성이 가능하다.

자바스크립트에서 함수는 1급 객체이자, 1급 함수라서 콜백패턴, 고차함수, 클로저, 커링, 메모이제이션 등이 가능해진다.

### Function expresstion

> 함수 선언식

(작성중)

> 함수 표현식

(작성중)

### literal-expression-statement

> 값, 식, 문

1. 값
   값은 프로그램에 의해 조작될 수 있는 대상을 말한다. 값은 다양한 방법으로 생성할 수 있으며, 가장 간단한 표기법은 리터럴이다.
   리터럴의 종류에는

   - 숫자 리터럴 `1001`
   - 문자열 리터럴 `"hi"`
   - 불리언 리터럴 `true`
   - null 리터럴 `null`
   - undefined 리터럴 `undefined`
   - 객체 리터럴 `{a:'1'}`
   - 배열 리터럴 `[1,2,3,4]`
   - 정규 표현식 리터럴 `/ab+c/`
   - 함수 리터럴 `function(){}`
     등이 있다.

2. 식
   식은 하나의 값으로 평가된다. 값, 변수, 객체의 프로퍼티, 배열의 요소, 함수 호출, 메소드 호출, 피연산자와 연산자 조합은 모두 표현식이고 하나의 값으로 평가된다.

   - `5*10 > 10`

3. 문
   문은 리터럴, 연산자, 표현식, 키워드 등으로 구성되고 세미콜론으로 끝나며, 프로그램에 의해 단계별로 수행될 명령들의 집합이다.
   - `var x = 5;`
   - `var z = x + y;`

식은 값으로 평가되기 때문에, 보통 '문'과 '식'으로 비교를 많이한다. '문'과 '식'의 차이는 `식은 값인 것`이고, `문은 값이 아닌것`이라고 할 수 있다.

### arrow function vs regular function

> 화살표 함수와 function의 차이점은 무엇인가요?

화살표 함수는 function 표현에 비해서 구문이 짧고(그래서 콜백 함수로 사용하기 적합), 자신의 this, arguments 등을 바인딩 하지 않습니다. (arguments 대시넹 rest 파라미터를 사용할 수 있습니다.) 또한 화살표함수는 prototype 속성이 없습니다.

화살표 함수는 항상 익명함수이고, function은 익명함수 또는 이름을 정의할 수 있습니다.

this가 따로 바인딩 되지 않으니까, 선언된 코드 바로 바깥의 함수의 this(lexical this)를 사용하는 것과 같습니다.
그에 반해, function의 this는 아래 처럼, 함수 종류에 따라서 this가 가리키는 객체가 다릅니다.

- 생성자 => 새로운 객체
- strict 모드 => undefined
- 메소드: 베이스 객체
- 콜백: 전역 객체 window

### Higher-order-function

> 고차 함수란 무엇인가요?

고차 함수는 한개 이상의 함수가 argument(전달인자) 이거나, 함수를 리턴시키는 함수를 의미합니다.

<code>const hof = () => () => 5</code>

높은 추상화가 적용된 고차 함수를 사용해서 명령형인 코드가 아니라, 선언적인 코드를 작성할 수 있다.
ex) filter이라는 고차 함수를 쓰지 않으면, for문을 활용해서 불필요한 코드들이 사용됨.

고차 함수를 활용하는 경우는 다음과 같습니다.

- 클로저

  ```js
  const closure = function () {
    let count = 0;
    return function increment() {
      count++;
      return count;
    };
  };
  const incrementFn = closure();
  incrementFn(); // 1
  incrementFn(); // 2
  ```

- 메모이제이션/캐싱

  ```js
  function memoizedAddTo80() {
    let cache = {};
    return function (n) {
      if (n in cache) {
        return cache[n];
      } else {
        cache[n] = n + 80;
        return cache[n];
      }
    };
  }

  const memoized = memoizedAddTo80();
  memoized(5); // 85
  ```

- 그 외 함수형 프로그래밍
  여기서 고차함수가 빛을 발하는 순간은 바로 [함수형 프로그래밍](#functional-programming)이다.

###functional programming

> 함수형 프로그래밍

함수형 프로그래밍을 사용함으로써 얻을 수 있는 장점 대표적인 2가지는
"높은 수준의 추상화", "함수 단위의 재사용"이 있다.

1.  높은 수준의 추상화
    기본적으로 함수형 프로그래밍은 선언형 프로그래밍의 특성을 함수들의 조합을 사용하여 구현하는 패러다임이다.
    명령형 프로그래밍, 객체지향 프로그래밍 보다 높은 수준의 추상화를 통해서 개발자가 문제 해결에만 집중할 수 있게 해준다는 점이 큰 장점이다.

    코딩테스트를 c++로 보거나, python/js로 볼때 큰 차이점을 느낀 사람도 있을 것이다. c++은 대표적인 명령형 프로그래밍으로 사용자가 컴퓨터에게 어떻게 동작해야할지 로우 레벨까지 일일히 모두 정의해줘야하지만, python/js는 높은 수준의 추상화를 통해서 사용자가 오로지 문제해결에만 집중할 수 있도록 도와주어 코딩테스트에 유리하다고 할 수 있다. (python이 js보다 내장 라이브러리가 더 많아서 인기 많음.)

    포토샵도 그렇다. 이미지 프로세싱은 생각보다 복잡한 연산을 필요로하는데 우리는 포토샵이 제공하는 추상화된 기능들을 통해서 포토샵 행위에만 집중할 수 있다.

    즉, 높은 수준의 추상화는 복잡한 무언가에서 핵심적인 개념이나 기능을 간추려서 단순하게 만드는 것을 의미하고 이것은 사용자가 프로그램을 사용하는데 있어서 편함을 제공할 수 있다.

    물론, 높은 수준의 추상화의 단점은 "성능이 안좋다", "이렇게 추상화하면 최적화는 어떻게 하나"와 같은 논란에 휩싸이고 대표적으로 자바, GC가 있다. [예시](https://evan-moon.github.io/2019/12/15/about-functional-thinking/)

2.  함수 단위의 코드 재사용
    객체지향 프로그래밍에서 어떤 존재를 추상화하여 표현하고 재사용할 수 있는 최소 단위는 객체이기 때문에, 그 이상 작게 쪼개기 힘들어진다. 하지만 함수형 프로그래밍에서는 객체로 표현된 큐나 스택이 아닌, 이 존재들의 자료를 다루는 동작에만 집중한다.
    예를 들어서

```js
const queue = [1, 2, 3];
queue.push(4);
const head = queue.shift();

const stack = [1, 2, 3];
stack.unshift(0);
stack.shift();
```

위와 같은 코드처럼, 딱히 객체로 선언하지 않아도 함수들을 재사용할 수 있다.

다만, 이렇게 작은 단위의 함수를 넓은 범위로 재사용하게 되면, 프로그램의 복잡성이 빠르게 증가하기 때문에 이를 방어하기 위해서, 함수가 함수 외부에 있는 값을 수정하면 안된다거나, 같은 input이면 같은 output을 반환해야한다는 몇 가지 제약 조건이 필요하게 되었는데 그렇게 탄생한 개념이 `순수 함수`이다.

### iife

> 즉시 실행 함수 (IIFE)

Immediately Invoked Function Expression

즉, 정의되자마자 즉시 실행되는 함수를 뜻한다.

> 어떻게 동작하나요?

```js
(function () {
  statements;
})();
```

크게 2가지로 구분할 수 있다.

1. ()로 둘러싸인 익명함수
2. 즉시 실행 함수를 생성하는 ()

`function() {}` 으로만 선언되는 경우, 파서는 '문'으로 인식합니다.
'문'은 자바스크립트 해석기에게 명령을 지시하고 사라지는 것이기 때문에 '값'으로 남지 않습니다.

따라서, ()으로 묶어서 함수 선언'문'이 아닌, 함수 표현'식'이라는 것을 명시적으로 나타내어야 합니다.
물론 ()으로 묶지 않더라도, 앞에 연산자를 붙여준다면 즉시 실행 함수로 사용할 수 있습니다.

```js
+(function (a, b) {
  return console.log(a + 1);
})(1 + 2)(
  // 3
  function (a, b) {
    return console.log(a + 1);
  }
)(1 + 2); // 3
```

### optional-chaining

> 옵셔널 체이닝은 언제 사용해야 하나요?

존재하지 않을 수도 있는 메서드를 호출할떄 사용한다.
즉, 함수 호출과 optional chaining을 사용하면, 메서드를 찾을 수 없는 경우에
해당 표현식이 자동으로 undefined를 반환하게 할 수 있다.

### context-scope

> 컨텍스트와 스코프에 대해서 설명해주세요.

1. 컨텍스트
   컨텍스트는 객체를 기반으로 한 용어로써, 함수가 어떻게 호출되는지에 따라서 this를 지칭하는 객체가 달라지게 되는데, 이렇게 현재 this가 무엇을 지칭하느냐를 구분짓는 것이 컨텍스트이다.
   만약, 함수 a와 b의 this가 서로 다른 객체를 지칭하고 있는경우, 두 함수의 컨텍스트는 다르다고 할 수 있다.

2. 스코프
   스코프는 함수를 기반으로한 용어이다. 특정 함수가 실행될 때,
   해당 함수에서 변수에 대한 접근 범위가 어디까지 인지를 나타내는 개념이 스코프이다.
